// This file was automatically generated by EbnfStudio; don't modify it!
#include "ObTokenType.h"

namespace Ob {
	const char* tokenTypeString( int r ) {
		switch(r) {
			case Tok_Invalid: return "<invalid>";
			case Tok_Hash: return "#";
			case Tok_Dlr: return "$";
			case Tok_Amp: return "&";
			case Tok_Lpar: return "(";
			case Tok_Latt: return "(*";
			case Tok_Rpar: return ")";
			case Tok_Star: return "*";
			case Tok_Ratt: return "*)";
			case Tok_Plus: return "+";
			case Tok_Comma: return ",";
			case Tok_Minus: return "-";
			case Tok_Dot: return ".";
			case Tok_2Dot: return "..";
			case Tok_Slash: return "/";
			case Tok_2Slash: return "//";
			case Tok_Colon: return ":";
			case Tok_ColonEq: return ":=";
			case Tok_Semi: return ";";
			case Tok_Lt: return "<";
			case Tok_Leq: return "<=";
			case Tok_Eq: return "=";
			case Tok_Gt: return ">";
			case Tok_Geq: return ">=";
			case Tok_Lbrack: return "[";
			case Tok_Rbrack: return "]";
			case Tok_Hat: return "^";
			case Tok_Lbrace: return "{";
			case Tok_Bar: return "|";
			case Tok_Rbrace: return "}";
			case Tok_Tilde: return "~";
			case Tok_ARRAY: return "ARRAY";
			case Tok_BEGIN: return "BEGIN";
			case Tok_BY: return "BY";
			case Tok_CARRAY: return "CARRAY";
			case Tok_CASE: return "CASE";
			case Tok_CONST: return "CONST";
			case Tok_CPOINTER: return "CPOINTER";
			case Tok_CSTRUCT: return "CSTRUCT";
			case Tok_CUNION: return "CUNION";
			case Tok_DEFINITION: return "DEFINITION";
			case Tok_DIV: return "DIV";
			case Tok_DO: return "DO";
			case Tok_ELSE: return "ELSE";
			case Tok_ELSIF: return "ELSIF";
			case Tok_END: return "END";
			case Tok_EXIT: return "EXIT";
			case Tok_FALSE: return "FALSE";
			case Tok_FOR: return "FOR";
			case Tok_IF: return "IF";
			case Tok_IMPORT: return "IMPORT";
			case Tok_IN: return "IN";
			case Tok_IS: return "IS";
			case Tok_LOOP: return "LOOP";
			case Tok_MOD: return "MOD";
			case Tok_MODULE: return "MODULE";
			case Tok_NIL: return "NIL";
			case Tok_OF: return "OF";
			case Tok_OR: return "OR";
			case Tok_POINTER: return "POINTER";
			case Tok_PROC: return "PROC";
			case Tok_PROCEDURE: return "PROCEDURE";
			case Tok_RECORD: return "RECORD";
			case Tok_REPEAT: return "REPEAT";
			case Tok_RETURN: return "RETURN";
			case Tok_THEN: return "THEN";
			case Tok_TO: return "TO";
			case Tok_TRUE: return "TRUE";
			case Tok_TYPE: return "TYPE";
			case Tok_UNSAFE: return "UNSAFE";
			case Tok_UNTIL: return "UNTIL";
			case Tok_VAR: return "VAR";
			case Tok_WHILE: return "WHILE";
			case Tok_WITH: return "WITH";
			case Tok_ident: return "ident";
			case Tok_integer: return "integer";
			case Tok_real: return "real";
			case Tok_string: return "string";
			case Tok_hexchar: return "hexchar";
			case Tok_hexstring: return "hexstring";
			case Tok_Comment: return "Comment";
			case Tok_Eof: return "<eof>";
			case R_type: return "type";
			case R_selector: return "selector";
			case R_ProcedureHeading: return "ProcedureHeading";
			case R_TypeActuals: return "TypeActuals";
			case R_SimpleExpression: return "SimpleExpression";
			case R_factor: return "factor";
			case R_qualident: return "qualident";
			case R_LoopStatement: return "LoopStatement";
			case R_DeclarationSequence2: return "DeclarationSequence2";
			case R_relation: return "relation";
			case R_VariableDeclaration: return "VariableDeclaration";
			case R_Case: return "Case";
			case R_NamedType: return "NamedType";
			case R_ReturnType: return "ReturnType";
			case R_label: return "label";
			case R_set: return "set";
			case R_WhileStatement: return "WhileStatement";
			case R_ProcedureDeclaration: return "ProcedureDeclaration";
			case R_LabelRange: return "LabelRange";
			case R_Guard: return "Guard";
			case R_FormalParameters: return "FormalParameters";
			case R_FieldListSequence: return "FieldListSequence";
			case R_ElseStatement: return "ElseStatement";
			case R_Receiver: return "Receiver";
			case R_CaseStatement: return "CaseStatement";
			case R_ConstDeclaration: return "ConstDeclaration";
			case R_element: return "element";
			case R_ElsifStatement: return "ElsifStatement";
			case R_CaseLabelList: return "CaseLabelList";
			case R_number: return "number";
			case R_RepeatStatement: return "RepeatStatement";
			case R_ElsifStatement2: return "ElsifStatement2";
			case R_ExpList: return "ExpList";
			case R_StatementSequence: return "StatementSequence";
			case R_FormalType: return "FormalType";
			case R_ArrayType: return "ArrayType";
			case R_assignmentOrProcedureCall: return "assignmentOrProcedureCall";
			case R_ReturnStatement: return "ReturnStatement";
			case R_RecordType: return "RecordType";
			case R_MulOperator: return "MulOperator";
			case R_TypeDeclaration: return "TypeDeclaration";
			case R_IfStatement: return "IfStatement";
			case R_term: return "term";
			case R_definition: return "definition";
			case R_SysAttr: return "SysAttr";
			case R_designator: return "designator";
			case R_ProcedureType: return "ProcedureType";
			case R_identdef: return "identdef";
			case R_TypeParams: return "TypeParams";
			case R_WithStatement: return "WithStatement";
			case R_variableOrFunctionCall: return "variableOrFunctionCall";
			case R_ProcedureBody: return "ProcedureBody";
			case R_import: return "import";
			case R_LengthList: return "LengthList";
			case R_ExitStatement: return "ExitStatement";
			case R_ImportList: return "ImportList";
			case R_module: return "module";
			case R_IdentList: return "IdentList";
			case R_enumeration: return "enumeration";
			case R_expression: return "expression";
			case R_TypeActual: return "TypeActual";
			case R_SystemAttrs: return "SystemAttrs";
			case R_statement: return "statement";
			case R_AddOperator: return "AddOperator";
			case R_DeclarationSequence: return "DeclarationSequence";
			case R_FieldList: return "FieldList";
			case R_PointerType: return "PointerType";
			case R_FPSection: return "FPSection";
			case R_BaseType: return "BaseType";
			case R_ForStatement: return "ForStatement";
			case R_literal: return "literal";
			default: return "";
		}
	}
	const char* tokenTypeName( int r ) {
		switch(r) {
			case Tok_Invalid: return "Tok_Invalid";
			case Tok_Hash: return "Tok_Hash";
			case Tok_Dlr: return "Tok_Dlr";
			case Tok_Amp: return "Tok_Amp";
			case Tok_Lpar: return "Tok_Lpar";
			case Tok_Latt: return "Tok_Latt";
			case Tok_Rpar: return "Tok_Rpar";
			case Tok_Star: return "Tok_Star";
			case Tok_Ratt: return "Tok_Ratt";
			case Tok_Plus: return "Tok_Plus";
			case Tok_Comma: return "Tok_Comma";
			case Tok_Minus: return "Tok_Minus";
			case Tok_Dot: return "Tok_Dot";
			case Tok_2Dot: return "Tok_2Dot";
			case Tok_Slash: return "Tok_Slash";
			case Tok_2Slash: return "Tok_2Slash";
			case Tok_Colon: return "Tok_Colon";
			case Tok_ColonEq: return "Tok_ColonEq";
			case Tok_Semi: return "Tok_Semi";
			case Tok_Lt: return "Tok_Lt";
			case Tok_Leq: return "Tok_Leq";
			case Tok_Eq: return "Tok_Eq";
			case Tok_Gt: return "Tok_Gt";
			case Tok_Geq: return "Tok_Geq";
			case Tok_Lbrack: return "Tok_Lbrack";
			case Tok_Rbrack: return "Tok_Rbrack";
			case Tok_Hat: return "Tok_Hat";
			case Tok_Lbrace: return "Tok_Lbrace";
			case Tok_Bar: return "Tok_Bar";
			case Tok_Rbrace: return "Tok_Rbrace";
			case Tok_Tilde: return "Tok_Tilde";
			case Tok_ARRAY: return "Tok_ARRAY";
			case Tok_BEGIN: return "Tok_BEGIN";
			case Tok_BY: return "Tok_BY";
			case Tok_CARRAY: return "Tok_CARRAY";
			case Tok_CASE: return "Tok_CASE";
			case Tok_CONST: return "Tok_CONST";
			case Tok_CPOINTER: return "Tok_CPOINTER";
			case Tok_CSTRUCT: return "Tok_CSTRUCT";
			case Tok_CUNION: return "Tok_CUNION";
			case Tok_DEFINITION: return "Tok_DEFINITION";
			case Tok_DIV: return "Tok_DIV";
			case Tok_DO: return "Tok_DO";
			case Tok_ELSE: return "Tok_ELSE";
			case Tok_ELSIF: return "Tok_ELSIF";
			case Tok_END: return "Tok_END";
			case Tok_EXIT: return "Tok_EXIT";
			case Tok_FALSE: return "Tok_FALSE";
			case Tok_FOR: return "Tok_FOR";
			case Tok_IF: return "Tok_IF";
			case Tok_IMPORT: return "Tok_IMPORT";
			case Tok_IN: return "Tok_IN";
			case Tok_IS: return "Tok_IS";
			case Tok_LOOP: return "Tok_LOOP";
			case Tok_MOD: return "Tok_MOD";
			case Tok_MODULE: return "Tok_MODULE";
			case Tok_NIL: return "Tok_NIL";
			case Tok_OF: return "Tok_OF";
			case Tok_OR: return "Tok_OR";
			case Tok_POINTER: return "Tok_POINTER";
			case Tok_PROC: return "Tok_PROC";
			case Tok_PROCEDURE: return "Tok_PROCEDURE";
			case Tok_RECORD: return "Tok_RECORD";
			case Tok_REPEAT: return "Tok_REPEAT";
			case Tok_RETURN: return "Tok_RETURN";
			case Tok_THEN: return "Tok_THEN";
			case Tok_TO: return "Tok_TO";
			case Tok_TRUE: return "Tok_TRUE";
			case Tok_TYPE: return "Tok_TYPE";
			case Tok_UNSAFE: return "Tok_UNSAFE";
			case Tok_UNTIL: return "Tok_UNTIL";
			case Tok_VAR: return "Tok_VAR";
			case Tok_WHILE: return "Tok_WHILE";
			case Tok_WITH: return "Tok_WITH";
			case Tok_ident: return "Tok_ident";
			case Tok_integer: return "Tok_integer";
			case Tok_real: return "Tok_real";
			case Tok_string: return "Tok_string";
			case Tok_hexchar: return "Tok_hexchar";
			case Tok_hexstring: return "Tok_hexstring";
			case Tok_Comment: return "Tok_Comment";
			case Tok_Eof: return "Tok_Eof";
			case R_type: return "R_type";
			case R_selector: return "R_selector";
			case R_ProcedureHeading: return "R_ProcedureHeading";
			case R_TypeActuals: return "R_TypeActuals";
			case R_SimpleExpression: return "R_SimpleExpression";
			case R_factor: return "R_factor";
			case R_qualident: return "R_qualident";
			case R_LoopStatement: return "R_LoopStatement";
			case R_DeclarationSequence2: return "R_DeclarationSequence2";
			case R_relation: return "R_relation";
			case R_VariableDeclaration: return "R_VariableDeclaration";
			case R_Case: return "R_Case";
			case R_NamedType: return "R_NamedType";
			case R_ReturnType: return "R_ReturnType";
			case R_label: return "R_label";
			case R_set: return "R_set";
			case R_WhileStatement: return "R_WhileStatement";
			case R_ProcedureDeclaration: return "R_ProcedureDeclaration";
			case R_LabelRange: return "R_LabelRange";
			case R_Guard: return "R_Guard";
			case R_FormalParameters: return "R_FormalParameters";
			case R_FieldListSequence: return "R_FieldListSequence";
			case R_ElseStatement: return "R_ElseStatement";
			case R_Receiver: return "R_Receiver";
			case R_CaseStatement: return "R_CaseStatement";
			case R_ConstDeclaration: return "R_ConstDeclaration";
			case R_element: return "R_element";
			case R_ElsifStatement: return "R_ElsifStatement";
			case R_CaseLabelList: return "R_CaseLabelList";
			case R_number: return "R_number";
			case R_RepeatStatement: return "R_RepeatStatement";
			case R_ElsifStatement2: return "R_ElsifStatement2";
			case R_ExpList: return "R_ExpList";
			case R_StatementSequence: return "R_StatementSequence";
			case R_FormalType: return "R_FormalType";
			case R_ArrayType: return "R_ArrayType";
			case R_assignmentOrProcedureCall: return "R_assignmentOrProcedureCall";
			case R_ReturnStatement: return "R_ReturnStatement";
			case R_RecordType: return "R_RecordType";
			case R_MulOperator: return "R_MulOperator";
			case R_TypeDeclaration: return "R_TypeDeclaration";
			case R_IfStatement: return "R_IfStatement";
			case R_term: return "R_term";
			case R_definition: return "R_definition";
			case R_SysAttr: return "R_SysAttr";
			case R_designator: return "R_designator";
			case R_ProcedureType: return "R_ProcedureType";
			case R_identdef: return "R_identdef";
			case R_TypeParams: return "R_TypeParams";
			case R_WithStatement: return "R_WithStatement";
			case R_variableOrFunctionCall: return "R_variableOrFunctionCall";
			case R_ProcedureBody: return "R_ProcedureBody";
			case R_import: return "R_import";
			case R_LengthList: return "R_LengthList";
			case R_ExitStatement: return "R_ExitStatement";
			case R_ImportList: return "R_ImportList";
			case R_module: return "R_module";
			case R_IdentList: return "R_IdentList";
			case R_enumeration: return "R_enumeration";
			case R_expression: return "R_expression";
			case R_TypeActual: return "R_TypeActual";
			case R_SystemAttrs: return "R_SystemAttrs";
			case R_statement: return "R_statement";
			case R_AddOperator: return "R_AddOperator";
			case R_DeclarationSequence: return "R_DeclarationSequence";
			case R_FieldList: return "R_FieldList";
			case R_PointerType: return "R_PointerType";
			case R_FPSection: return "R_FPSection";
			case R_BaseType: return "R_BaseType";
			case R_ForStatement: return "R_ForStatement";
			case R_literal: return "R_literal";
			default: return "";
		}
	}
	bool tokenTypeIsLiteral( int r ) {
		return r > TT_Literals && r < TT_Keywords;
	}
	bool tokenTypeIsKeyword( int r ) {
		return r > TT_Keywords && r < TT_Specials;
	}
	bool tokenTypeIsSpecial( int r ) {
		return r > TT_Specials && r < TT_Nonterminals;
	}
	bool tokenTypeIsNonterminal( int r ) {
		return r > TT_Nonterminals && r < TT_Max;
	}
	static inline char at( const QByteArray& str, int i ){
		return ( i >= 0 && i < str.size() ? str[i] : 0 );
	}
	TokenType tokenTypeFromString( const QByteArray& str, int* pos ) {
		int i = ( pos != 0 ? *pos: 0 );
		TokenType res = Tok_Invalid;
		switch( at(str,i) ){
		case '#':
			res = Tok_Hash; i += 1;
			break;
		case '$':
			res = Tok_Dlr; i += 1;
			break;
		case '&':
			res = Tok_Amp; i += 1;
			break;
		case '(':
			if( at(str,i+1) == '*' ){
				res = Tok_Latt; i += 2;
			} else {
				res = Tok_Lpar; i += 1;
			}
			break;
		case ')':
			res = Tok_Rpar; i += 1;
			break;
		case '*':
			if( at(str,i+1) == ')' ){
				res = Tok_Ratt; i += 2;
			} else {
				res = Tok_Star; i += 1;
			}
			break;
		case '+':
			res = Tok_Plus; i += 1;
			break;
		case ',':
			res = Tok_Comma; i += 1;
			break;
		case '-':
			res = Tok_Minus; i += 1;
			break;
		case '.':
			if( at(str,i+1) == '.' ){
				res = Tok_2Dot; i += 2;
			} else {
				res = Tok_Dot; i += 1;
			}
			break;
		case '/':
			if( at(str,i+1) == '/' ){
				res = Tok_2Slash; i += 2;
			} else {
				res = Tok_Slash; i += 1;
			}
			break;
		case ':':
			if( at(str,i+1) == '=' ){
				res = Tok_ColonEq; i += 2;
			} else {
				res = Tok_Colon; i += 1;
			}
			break;
		case ';':
			res = Tok_Semi; i += 1;
			break;
		case '<':
			if( at(str,i+1) == '=' ){
				res = Tok_Leq; i += 2;
			} else {
				res = Tok_Lt; i += 1;
			}
			break;
		case '=':
			res = Tok_Eq; i += 1;
			break;
		case '>':
			if( at(str,i+1) == '=' ){
				res = Tok_Geq; i += 2;
			} else {
				res = Tok_Gt; i += 1;
			}
			break;
		case 'A':
			if( at(str,i+1) == 'R' ){
				if( at(str,i+2) == 'R' ){
					if( at(str,i+3) == 'A' ){
						if( at(str,i+4) == 'Y' ){
							res = Tok_ARRAY; i += 5;
						}
					}
				}
			}
			break;
		case 'B':
			switch( at(str,i+1) ){
			case 'E':
				if( at(str,i+2) == 'G' ){
					if( at(str,i+3) == 'I' ){
						if( at(str,i+4) == 'N' ){
							res = Tok_BEGIN; i += 5;
						}
					}
				}
				break;
			case 'Y':
				res = Tok_BY; i += 2;
				break;
			}
			break;
		case 'C':
			switch( at(str,i+1) ){
			case 'A':
				switch( at(str,i+2) ){
				case 'R':
					if( at(str,i+3) == 'R' ){
						if( at(str,i+4) == 'A' ){
							if( at(str,i+5) == 'Y' ){
								res = Tok_CARRAY; i += 6;
							}
						}
					}
					break;
				case 'S':
					if( at(str,i+3) == 'E' ){
						res = Tok_CASE; i += 4;
					}
					break;
				}
				break;
			case 'O':
				if( at(str,i+2) == 'N' ){
					if( at(str,i+3) == 'S' ){
						if( at(str,i+4) == 'T' ){
							res = Tok_CONST; i += 5;
						}
					}
				}
				break;
			case 'P':
				if( at(str,i+2) == 'O' ){
					if( at(str,i+3) == 'I' ){
						if( at(str,i+4) == 'N' ){
							if( at(str,i+5) == 'T' ){
								if( at(str,i+6) == 'E' ){
									if( at(str,i+7) == 'R' ){
										res = Tok_CPOINTER; i += 8;
									}
								}
							}
						}
					}
				}
				break;
			case 'S':
				if( at(str,i+2) == 'T' ){
					if( at(str,i+3) == 'R' ){
						if( at(str,i+4) == 'U' ){
							if( at(str,i+5) == 'C' ){
								if( at(str,i+6) == 'T' ){
									res = Tok_CSTRUCT; i += 7;
								}
							}
						}
					}
				}
				break;
			case 'U':
				if( at(str,i+2) == 'N' ){
					if( at(str,i+3) == 'I' ){
						if( at(str,i+4) == 'O' ){
							if( at(str,i+5) == 'N' ){
								res = Tok_CUNION; i += 6;
							}
						}
					}
				}
				break;
			}
			break;
		case 'D':
			switch( at(str,i+1) ){
			case 'E':
				if( at(str,i+2) == 'F' ){
					if( at(str,i+3) == 'I' ){
						if( at(str,i+4) == 'N' ){
							if( at(str,i+5) == 'I' ){
								if( at(str,i+6) == 'T' ){
									if( at(str,i+7) == 'I' ){
										if( at(str,i+8) == 'O' ){
											if( at(str,i+9) == 'N' ){
												res = Tok_DEFINITION; i += 10;
											}
										}
									}
								}
							}
						}
					}
				}
				break;
			case 'I':
				if( at(str,i+2) == 'V' ){
					res = Tok_DIV; i += 3;
				}
				break;
			case 'O':
				res = Tok_DO; i += 2;
				break;
			}
			break;
		case 'E':
			switch( at(str,i+1) ){
			case 'L':
				if( at(str,i+2) == 'S' ){
					switch( at(str,i+3) ){
					case 'E':
						res = Tok_ELSE; i += 4;
						break;
					case 'I':
						if( at(str,i+4) == 'F' ){
							res = Tok_ELSIF; i += 5;
						}
						break;
					}
				}
				break;
			case 'N':
				if( at(str,i+2) == 'D' ){
					res = Tok_END; i += 3;
				}
				break;
			case 'X':
				if( at(str,i+2) == 'I' ){
					if( at(str,i+3) == 'T' ){
						res = Tok_EXIT; i += 4;
					}
				}
				break;
			}
			break;
		case 'F':
			switch( at(str,i+1) ){
			case 'A':
				if( at(str,i+2) == 'L' ){
					if( at(str,i+3) == 'S' ){
						if( at(str,i+4) == 'E' ){
							res = Tok_FALSE; i += 5;
						}
					}
				}
				break;
			case 'O':
				if( at(str,i+2) == 'R' ){
					res = Tok_FOR; i += 3;
				}
				break;
			}
			break;
		case 'I':
			switch( at(str,i+1) ){
			case 'F':
				res = Tok_IF; i += 2;
				break;
			case 'M':
				if( at(str,i+2) == 'P' ){
					if( at(str,i+3) == 'O' ){
						if( at(str,i+4) == 'R' ){
							if( at(str,i+5) == 'T' ){
								res = Tok_IMPORT; i += 6;
							}
						}
					}
				}
				break;
			case 'N':
				res = Tok_IN; i += 2;
				break;
			case 'S':
				res = Tok_IS; i += 2;
				break;
			}
			break;
		case 'L':
			if( at(str,i+1) == 'O' ){
				if( at(str,i+2) == 'O' ){
					if( at(str,i+3) == 'P' ){
						res = Tok_LOOP; i += 4;
					}
				}
			}
			break;
		case 'M':
			if( at(str,i+1) == 'O' ){
				if( at(str,i+2) == 'D' ){
					if( at(str,i+3) == 'U' ){
						if( at(str,i+4) == 'L' ){
							if( at(str,i+5) == 'E' ){
								res = Tok_MODULE; i += 6;
							}
						}
					} else {
						res = Tok_MOD; i += 3;
					}
				}
			}
			break;
		case 'N':
			if( at(str,i+1) == 'I' ){
				if( at(str,i+2) == 'L' ){
					res = Tok_NIL; i += 3;
				}
			}
			break;
		case 'O':
			switch( at(str,i+1) ){
			case 'F':
				res = Tok_OF; i += 2;
				break;
			case 'R':
				res = Tok_OR; i += 2;
				break;
			}
			break;
		case 'P':
			switch( at(str,i+1) ){
			case 'O':
				if( at(str,i+2) == 'I' ){
					if( at(str,i+3) == 'N' ){
						if( at(str,i+4) == 'T' ){
							if( at(str,i+5) == 'E' ){
								if( at(str,i+6) == 'R' ){
									res = Tok_POINTER; i += 7;
								}
							}
						}
					}
				}
				break;
			case 'R':
				if( at(str,i+2) == 'O' ){
					if( at(str,i+3) == 'C' ){
						if( at(str,i+4) == 'E' ){
							if( at(str,i+5) == 'D' ){
								if( at(str,i+6) == 'U' ){
									if( at(str,i+7) == 'R' ){
										if( at(str,i+8) == 'E' ){
											res = Tok_PROCEDURE; i += 9;
										}
									}
								}
							}
						} else {
							res = Tok_PROC; i += 4;
						}
					}
				}
				break;
			}
			break;
		case 'R':
			if( at(str,i+1) == 'E' ){
				switch( at(str,i+2) ){
				case 'C':
					if( at(str,i+3) == 'O' ){
						if( at(str,i+4) == 'R' ){
							if( at(str,i+5) == 'D' ){
								res = Tok_RECORD; i += 6;
							}
						}
					}
					break;
				case 'P':
					if( at(str,i+3) == 'E' ){
						if( at(str,i+4) == 'A' ){
							if( at(str,i+5) == 'T' ){
								res = Tok_REPEAT; i += 6;
							}
						}
					}
					break;
				case 'T':
					if( at(str,i+3) == 'U' ){
						if( at(str,i+4) == 'R' ){
							if( at(str,i+5) == 'N' ){
								res = Tok_RETURN; i += 6;
							}
						}
					}
					break;
				}
			}
			break;
		case 'T':
			switch( at(str,i+1) ){
			case 'H':
				if( at(str,i+2) == 'E' ){
					if( at(str,i+3) == 'N' ){
						res = Tok_THEN; i += 4;
					}
				}
				break;
			case 'O':
				res = Tok_TO; i += 2;
				break;
			case 'R':
				if( at(str,i+2) == 'U' ){
					if( at(str,i+3) == 'E' ){
						res = Tok_TRUE; i += 4;
					}
				}
				break;
			case 'Y':
				if( at(str,i+2) == 'P' ){
					if( at(str,i+3) == 'E' ){
						res = Tok_TYPE; i += 4;
					}
				}
				break;
			}
			break;
		case 'U':
			if( at(str,i+1) == 'N' ){
				switch( at(str,i+2) ){
				case 'S':
					if( at(str,i+3) == 'A' ){
						if( at(str,i+4) == 'F' ){
							if( at(str,i+5) == 'E' ){
								res = Tok_UNSAFE; i += 6;
							}
						}
					}
					break;
				case 'T':
					if( at(str,i+3) == 'I' ){
						if( at(str,i+4) == 'L' ){
							res = Tok_UNTIL; i += 5;
						}
					}
					break;
				}
			}
			break;
		case 'V':
			if( at(str,i+1) == 'A' ){
				if( at(str,i+2) == 'R' ){
					res = Tok_VAR; i += 3;
				}
			}
			break;
		case 'W':
			switch( at(str,i+1) ){
			case 'H':
				if( at(str,i+2) == 'I' ){
					if( at(str,i+3) == 'L' ){
						if( at(str,i+4) == 'E' ){
							res = Tok_WHILE; i += 5;
						}
					}
				}
				break;
			case 'I':
				if( at(str,i+2) == 'T' ){
					if( at(str,i+3) == 'H' ){
						res = Tok_WITH; i += 4;
					}
				}
				break;
			}
			break;
		case '[':
			res = Tok_Lbrack; i += 1;
			break;
		case ']':
			res = Tok_Rbrack; i += 1;
			break;
		case '^':
			res = Tok_Hat; i += 1;
			break;
		case '{':
			res = Tok_Lbrace; i += 1;
			break;
		case '|':
			res = Tok_Bar; i += 1;
			break;
		case '}':
			res = Tok_Rbrace; i += 1;
			break;
		case '~':
			res = Tok_Tilde; i += 1;
			break;
		}
		if(pos) *pos = i;
		return res;
	}
}
